<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custom HLS Player</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@0.14.17"></script>
  <style>
    body {
      margin:0; background:#000; width:100vw; height:100vh;
      display:flex; flex-direction:column; font-family:Arial, sans-serif;
    }
    #topBar {
      background:rgba(0,0,0,0.6); color:#fff;
      padding:8px; text-align:center;
      display:none; /* default hidden, show only for series */
      position:absolute; top:0; left:0; width:100%;
      z-index:1000;
    }
    #videoContainer {
      flex:1; position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center;
      background:#000;
    }
    video {
      width:100%; height:100%; object-fit:contain;
      background:#000;
    }
    #subtitleOverlay {
      position:absolute; pointer-events:none;
      display:none; opacity:0;
      transition:opacity 0.4s ease;
      max-width:60%; max-height:25%;
      left:50%; bottom:8%; transform:translateX(-50%);
      filter:drop-shadow(0 2px 4px rgba(0,0,0,0.7));
      border-radius:6px; background-color:rgba(0,0,0,0.2);
    }
    #controls {
      background:#111; color:#fff; padding:12px;
      display:flex; gap:12px; justify-content:center; flex-wrap:wrap;
      border-top:1px solid #333;
    }
    select, button {
      padding:8px 14px;
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.25);
      color:#fff; border-radius:6px;
      cursor:pointer; transition:all 0.25s ease;
      font-size:14px;
    }
    select:hover, button:hover {
      background:rgba(255,255,255,0.2);
      border-color:#fff;
      transform:scale(1.05);
    }
    button:active { transform:scale(0.95); }
    #videoTitle {
      font-size:16px; font-weight:bold;
    }
  </style>
</head>
<body>
  <!-- Top bar: ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ series -->
  <div id="topBar">
    <div id="videoTitle"></div>
    <div id="selectorBar">
      <label>Season: <select id="seasonSelect"></select></label>
      <label>Episode: <select id="episodeSelect"></select></label>
    </div>
  </div>

  <!-- Video + Subtitle Overlay -->
  <div id="videoContainer">
    <video id="video" autoplay crossorigin="anonymous"></video>
    <img id="subtitleOverlay" />
  </div>

  <!-- Controls -->
  <div id="controls">
    <label>Audio: <select id="audioSelector"></select></label>
    <label>Quality: <select id="qualitySelector"></select></label>
    <label>Subtitle: <select id="subtitleSelector"><option value="none">No Subtitles</option></select></label>
    <button id="playBtn">‚ñ∂Ô∏è Play</button>
    <button id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button id="muteBtn">üîä Mute</button>
    <button id="backwardBtn">‚è™ -10s</button>
    <button id="forwardBtn">‚è© +10s</button>
    <button id="fullscreenBtn">‚õ∂ Fullscreen</button>
  </div>

<!-- Script Part 1: Utilities + Parsers + Subtitle Handling -->
<script>
// --- Utilities ---
async function checkSubtitleExists(url){ 
  try{ const res=await fetch(url,{method:"HEAD"}); return res.ok; }
  catch{ return false; } 
}
function extractAudioTracks(m3uText){ 
  const tracks=[]; 
  const regex=/#EXT-X-MEDIA:TYPE=AUDIO.*?LANGUAGE="(.*?)".*?NAME="(.*?)".*?URI="(.*?)"/g; 
  let match;
  while((match=regex.exec(m3uText))!==null){ 
    tracks.push({lang:match[1],name:match[2],uri:match[3]}); 
  } 
  return tracks; 
}

// --- Subtitle Metadata Loader with fallback ---
async function fetchSubtitleMetadata(cdnHostname, transcodeUuid){
  const url = `https://${cdnHostname}/${transcodeUuid}/subtitle_metadata.json`;
  try {
    const res = await fetch(url);
    if(!res.ok){
      console.warn("Subtitle metadata not found, using fallback");
      return {
        eng:[],
        tha:[
          {codec:"VTT", pathName:"subtha", error:false},
          {codec:"VTT", pathName:"subtha1", error:false},
          {codec:"BDN", pathName:"subtha_2", error:false}
        ],
        default:[]
      };
    }
    const data = await res.json();
    return data;
  } catch(err){
    console.error("Error fetching subtitle metadata:", err);
    return {
      eng:[],
      tha:[
        {codec:"VTT", pathName:"subtha", error:false},
        {codec:"VTT", pathName:"subtha1", error:false},
        {codec:"BDN", pathName:"subtha_2", error:false}
      ],
      default:[]
    };
  }
}

// --- BDN Conversion ---
function timecodeToVTT(tc){
  const [hh,mm,ss,ms] = tc.split(/[:.]/).map(Number);
  const total = hh*3600 + mm*60 + ss + (ms||0)/1000;
  const h = String(Math.floor(total/3600)).padStart(2,"0");
  const m = String(Math.floor((total%3600)/60)).padStart(2,"0");
  const s = String(Math.floor(total%60)).padStart(2,"0");
  const msStr = String(Math.floor((total%1)*1000)).padStart(3,"0");
  return `${h}:${m}:${s}.${msStr}`;
}
function convertBDNtoVTT(xmlText){
  const xmlDoc = new DOMParser().parseFromString(xmlText,"application/xml");
  const events = xmlDoc.querySelectorAll("Event");
  let vtt = "WEBVTT\n\n";
  events.forEach((ev,idx)=>{
    const start = timecodeToVTT(ev.getAttribute("InTC"));
    const end = timecodeToVTT(ev.getAttribute("OutTC"));
    const g = ev.querySelector("Graphic");
    if(!g) return;
    const imgName = g.textContent.trim();
    vtt += `${idx+1}\n${start} --> ${end}\n${imgName}\n\n`;
  });
  return vtt;
}
async function loadBDNAsVTT(baseUrl, videoId, cdn, lang){
  const res = await fetch(`${baseUrl}/index.xml`);
  if(!res.ok) return {};
  const xmlText = await res.text();
  const folder = baseUrl.split('/').pop();
  const vttText = convertBDNtoVTT(xmlText);
  const blob = new Blob([vttText], {type:"text/vtt"});
  const vttUrl = URL.createObjectURL(blob);

  const track = document.createElement("track");
  track.kind = "subtitles";
  track.label = lang.toUpperCase();
  track.srclang = lang;
  track.src = vttUrl;
  track.mode = "hidden";
  video.appendChild(track);

  return {folder};
}

// --- Subtitle Rendering ---
const bdnSubtitles=[];
function renderSubtitleMenu(subtitles){
  const video=document.getElementById("video");
  const subtitleSelector=document.getElementById("subtitleSelector");
  subtitleSelector.innerHTML='<option value="none">No Subtitles</option>';
  bdnSubtitles.length=0;

  subtitles.forEach(sub=>{
    const opt=document.createElement("option");
    opt.value=sub.lang;
    opt.text=sub.lang.toUpperCase()+" ("+sub.codec+")";
    subtitleSelector.appendChild(opt);

    if(sub.codec==="VTT"){
      const track=document.createElement("track");
      track.kind="subtitles";
      track.label=sub.lang.toUpperCase();
      track.srclang=sub.lang;
      track.src=sub.src;
      video.appendChild(track);
    }
    if(sub.codec==="BDN"){
      bdnSubtitles.push(sub);
    }
  });

  subtitleSelector.onchange=async()=>{
    const selected=subtitleSelector.value;
    Array.from(video.textTracks).forEach(track=>track.mode="disabled");
    subtitleOverlay.style.display="none";
    subtitleOverlay.style.opacity="0";

    if(selected==="none") return;

    const vttTrack=Array.from(video.textTracks).find(
      t => t.srclang === selected || t.label.toLowerCase() === selected.toLowerCase()
    );
    if(vttTrack){
      vttTrack.mode="showing";
      return;
    }

    const bdnEntry=bdnSubtitles.find(sub=>sub.lang===selected);
    if(bdnEntry){
      const { folder }=await loadBDNAsVTT(
        bdnEntry.src.replace("/index.xml",""),
        bdnEntry.videoId,
        bdnEntry.cdn,
        bdnEntry.lang
      );
      activateBDNOverlay(folder, bdnEntry.videoId, bdnEntry.cdn, bdnEntry.lang);
    }
  };
}

// --- Responsive Overlay ---
function activateBDNOverlay(folder,videoId,cdn,lang){
  const track=Array.from(video.textTracks).find(
    t => t.srclang === lang || t.label.toLowerCase() === lang.toLowerCase()
  );
  if(!track) return;
  track.mode="hidden";

  video.addEventListener("timeupdate",()=>{
    const cue=Array.from(track.activeCues||[])[0];
    if(cue&&cue.text.trim()){
      const imgName=cue.text.replace(/<[^>]+>/g,"").trim();
      const imgURL=`https://${cdn}/${videoId}/${folder}/${imgName}`;
      subtitleOverlay.src=imgURL;
      subtitleOverlay.style.left=(video.clientWidth/2-(subtitleOverlay.width/2))+"px";
      subtitleOverlay.style.bottom=(video.clientHeight*0.08)+"px";
      subtitleOverlay.style.display="block";
      subtitleOverlay.style.opacity="1";
      cue.onexit = ()=>{ subtitleOverlay.style.opacity="0"; subtitleOverlay.style.display="none"; };
    } else {
      subtitleOverlay.style.opacity="0";
      subtitleOverlay.style.display="none";
    }
  });
}

// --- Movie Parser ---
async function fetchMovieById(movieId){ 
  const query=`query getMovie($id:Int!){ movie(id:$id){ id titleTh titleEn video{ transcodeUuid cdnHostname subtitleMetadata } } }`;
  const response=await fetch("https://api.doo-nang.com/graphql",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query,variables:{id:movieId}})});
  const result=await response.json(); const movie=result?.data?.movie; if(!movie) return null;
  const transcodeUuid=movie.video?.transcodeUuid, cdnHostname=movie.video?.cdnHostname; let videoUrl="",subtitle=[],audioTracks=[];
  if(transcodeUuid&&cdnHostname){ 
    const base=`https://${cdnHostname}/${transcodeUuid}`; 
    videoUrl=`https://api.doo-nang.com/video/${transcodeUuid}/playlist.m3u8`;
    const metadata=await fetchSubtitleMetadata(cdnHostname,transcodeUuid);
    for(const [lang,subs] of Object.entries(metadata)){ 
      for(const sub of subs){ 
        let src;
        if(sub.codec==="VTT") src=`${base}/${sub.pathName}.vtt`; 
        else if(sub.codec==="BDN") src=`${base}/${sub.pathName}/index.xml`;
        if(await checkSubtitleExists(src)) subtitle.push({lang,codec:sub.codec,src,cdn:cdnHostname,videoId:transcodeUuid}); 
      } 
    }
    try{ const res=await fetch(videoUrl); if(res.ok) audioTracks=extractAudioTracks(await res.text()); }catch{} 
  }
  return { id:movie.id, title:movie.titleTh||movie.titleEn, video:videoUrl, subtitle, audioTracks }; 
}

// --- Series Parser ---
async function fetchSeriesById(showId){ 
  const query=`query getShow($id:Int!){ show(id:$id){ id titleTh titleEn episodes{ seasonNo episodeNo titleTh titleEn video{ transcodeUuid cdnHostname subtitleMetadata } } } }`;
  const response=await fetch("https://api.doo-nang.com/graphql",{
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify({query,variables:{id:showId}})
  });
  const result=await response.json(); 
  return result?.data?.show||null; 
}

async function processEpisode(ep){ 
  const transcodeUuid=ep.video?.transcodeUuid, cdnHostname=ep.video?.cdnHostname; 
  let videoUrl="",subtitle=[],audioTracks=[];
  if(transcodeUuid&&cdnHostname){ 
    const base=`https://${cdnHostname}/${transcodeUuid}`; 
    videoUrl=`https://api.doo-nang.com/video/${transcodeUuid}/playlist.m3u8`;

    // ‚úÖ ‡πÉ‡∏ä‡πâ subtitle_metadata.json ‡∏û‡∏£‡πâ‡∏≠‡∏° fallback
    const metadata=await fetchSubtitleMetadata(cdnHostname,transcodeUuid);
    for(const [lang,subs] of Object.entries(metadata)){ 
      for(const sub of subs){ 
        let src;
        if(sub.codec==="VTT") src=`${base}/${sub.pathName}.vtt`; 
        else if(sub.codec==="BDN") src=`${base}/${sub.pathName}/index.xml`;
        if(await checkSubtitleExists(src)) subtitle.push({lang,codec:sub.codec,src,cdn:cdnHostname,videoId:transcodeUuid}); 
      } 
    }

    try{ 
      const res=await fetch(videoUrl); 
      if(res.ok) audioTracks=extractAudioTracks(await res.text()); 
    }catch{} 
  }
  return { 
    season:ep.seasonNo, 
    episode:ep.episodeNo, 
    title:ep.titleTh||ep.titleEn||`EP${ep.episodeNo}`, 
    video:videoUrl, 
    subtitle, 
    audioTracks 
  }; 
}

// --- Clear and Load Episode ---
function clearSubtitles(){
  const video=document.getElementById("video");
  Array.from(video.querySelectorAll("track")).forEach(t=>t.remove());
}

async function loadEpisode(ep){
  const episodeData = await processEpisode(ep);
  if(!episodeData) return;

  // ‡πÇ‡∏´‡∏•‡∏î video ‡πÉ‡∏´‡∏°‡πà
  video.src = episodeData.video;

  // ‚úÖ ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå subtitle ‡πÄ‡∏î‡∏¥‡∏°
  clearSubtitles();

  // ‚úÖ ‡πÇ‡∏´‡∏•‡∏î subtitle ‡πÉ‡∏´‡∏°‡πà
  renderSubtitleMenu(episodeData.subtitle);

  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á
  document.getElementById("videoTitle").textContent = episodeData.title;
}

// --- Load Series Episode by ids param ---
async function loadSeriesEpisode(showId, seasonNo, episodeNo){
  const series = await fetchSeriesById(showId);
  if(!series) return;

  const ep = series.episodes.find(
    e => e.seasonNo === seasonNo && e.episodeNo === episodeNo
  );
  if(!ep) return;

  await loadEpisode(ep);
}
</script>

<!-- Script Part 2: Player Init + Init Page -->
<script>
function initPlayer(videoURL){
  const video=document.getElementById("video");
  const audioSelector=document.getElementById("audioSelector");
  const qualitySelector=document.getElementById("qualitySelector");

  if(Hls.isSupported()){
    const hls=new Hls();
    hls.attachMedia(video);
    hls.loadSource(videoURL);

    hls.on(Hls.Events.MANIFEST_PARSED,()=>{
      // ‚úÖ ‡πÇ‡∏´‡∏•‡∏î Audio Tracks
      audioSelector.innerHTML='';
      hls.audioTracks.forEach((track,i)=>{
        const opt=document.createElement("option");
        opt.value=i;
        opt.text=`${track.name||'Track'} (${track.lang||'und'})`;
        audioSelector.appendChild(opt);
      });
      audioSelector.onchange=()=>{ hls.audioTrack=parseInt(audioSelector.value); };

      // ‚úÖ ‡πÇ‡∏´‡∏•‡∏î Quality Levels
      qualitySelector.innerHTML='<option value="-1">Auto</option>';
      hls.levels.forEach((level,i)=>{
        const label=level.height?`${level.height}p`:`${Math.round(level.bitrate/1000)}kbps`;
        const opt=document.createElement("option");
        opt.value=i; opt.text=label;
        qualitySelector.appendChild(opt);
      });
      qualitySelector.onchange=()=>{ hls.currentLevel=parseInt(qualitySelector.value); };
    });
  } else if(video.canPlayType("application/vnd.apple.mpegurl")){
    video.src=videoURL;
  }
}

window.onload = async () => {
  const params = new URLSearchParams(window.location.search);
  const type = params.get("type");
  const ids = params.get("ids");

  // ‚úÖ Movie Parser
  if(type==="movie" && ids){
    const movieId = parseInt(ids,10);
    const movie = await fetchMovieById(movieId);

    if(movie){
      initPlayer(movie.video);
      renderSubtitleMenu(movie.subtitle);
      document.getElementById("videoTitle").innerText = movie.title;

      // ‚ùå ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏™‡∏î‡∏á TopBar ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö movie
      document.getElementById("topBar").style.display = "none";
    } else {
      document.getElementById("videoTitle").innerText = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏ô‡∏±‡∏á";
    }
  }

  // ‚úÖ Series Parser
  if(type==="series" && ids){
    const parts = ids.split("/");
    const showId = parseInt(parts[0]);
    const seasonNo = parts[1] ? parseInt(parts[1]) : 1;
    const episodeNo = parts[2] ? parseInt(parts[2]) : 1;

    const show = await fetchSeriesById(showId);
    if(show){
      const seasonSelect=document.getElementById("seasonSelect");
      const episodeSelect=document.getElementById("episodeSelect");
      const topBar=document.getElementById("topBar");
      topBar.style.display="block"; // ‚úÖ ‡πÅ‡∏™‡∏î‡∏á TopBar ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ series

      const seasonMap={};
      show.episodes.forEach(ep=>{
        if(!seasonMap[ep.seasonNo]) seasonMap[ep.seasonNo]=[];
        seasonMap[ep.seasonNo].push(ep);
      });

      Object.keys(seasonMap).forEach(seasonNoKey=>{
        const opt=document.createElement("option");
        opt.value=`?type=series&ids=${showId}/${seasonNoKey}/1`;
        opt.text=`Season ${seasonNoKey}`;
        seasonSelect.appendChild(opt);
      });

      async function loadEpisodes(seasonNo, episodeNo=null){
        episodeSelect.innerHTML="";
        seasonMap[seasonNo].forEach(ep=>{
          const opt=document.createElement("option");
          opt.value=`?type=series&ids=${showId}/${seasonNo}/${ep.episodeNo}`;
          opt.text=`Episode ${ep.episodeNo} - ${ep.titleTh||ep.titleEn}`;
          episodeSelect.appendChild(opt);
        });

        let targetEp = episodeNo ? seasonMap[seasonNo].find(e => e.episodeNo == episodeNo) : seasonMap[seasonNo][0];
        if(targetEp){
          const epData = await processEpisode(targetEp);
          initPlayer(epData.video);
          renderSubtitleMenu(epData.subtitle);
          document.getElementById("videoTitle").innerText = epData.title;
          seasonSelect.value = `?type=series&ids=${showId}/${seasonNo}/1`;
          episodeSelect.value = `?type=series&ids=${showId}/${seasonNo}/${targetEp.episodeNo}`;
        }
      }

      seasonSelect.addEventListener("change", ()=>{ window.location.href = seasonSelect.value; });
      episodeSelect.addEventListener("change", ()=>{ window.location.href = episodeSelect.value; });

      await loadEpisodes(seasonNo, episodeNo);
    }
  }
};
</script>

<!-- Script Part 3: Button Controls -->
<script>
const video=document.getElementById("video");
document.getElementById("playBtn").addEventListener("click",()=>video.play());
document.getElementById("pauseBtn").addEventListener("click",()=>video.pause());
document.getElementById("muteBtn").addEventListener("click",()=>{
  video.muted=!video.muted;
  document.getElementById("muteBtn").textContent=video.muted?"üîá Unmute":"üîä Mute";
});
document.getElementById("forwardBtn").addEventListener("click",()=>video.currentTime+=10);
document.getElementById("backwardBtn").addEventListener("click",()=>video.currentTime-=10);

const fullscreenBtn=document.getElementById("fullscreenBtn"); 
fullscreenBtn.addEventListener("click",()=>{ 
  if(!document.fullscreenElement){ 
    document.body.requestFullscreen(); 
  } else { 
    document.exitFullscreen(); 
  } 
}); 

document.addEventListener("fullscreenchange",()=>{ 
  fullscreenBtn.textContent=document.fullscreenElement ? "Exit Fullscreen" : "‚õ∂ Fullscreen"; 
});
</script>
</body>
</html>