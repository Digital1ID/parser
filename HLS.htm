<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custom HLS Player</title>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@0.14.17"></script>
<style>
  body {
    margin:0; background:#000; width:100vw; height:100vh;
    display:flex; flex-direction:column; font-family:Arial, sans-serif;
  }
  video {
    flex:1; width:100%; height:100%; object-fit:contain;
    background:#000;
  }
  #subtitleOverlay {
    position: fixed; z-index: 9999; pointer-events: none;
    display: none; opacity: 0;
    transition: opacity 0.4s ease, transform 0.3s ease;
    max-width: 60%; max-height: 25%;
    left: 50%; bottom: 8%; transform: translateX(-50%);
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.7));
    border-radius: 6px; background-color: rgba(0,0,0,0.2);
  }
  #controls {
    background:#111; color:#fff; padding:12px;
    display:flex; gap:12px; justify-content:center; flex-wrap:wrap;
    border-top:1px solid #333;
  }
  select, button {
    padding:8px 14px;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.25);
    color:#fff; border-radius:6px;
    cursor:pointer; transition:all 0.25s ease;
    font-size:14px;
  }
  select:hover, button:hover {
    background:rgba(255,255,255,0.2);
    border-color:#fff;
    transform:scale(1.05);
  }
  button:active {
    transform:scale(0.95);
  }
  #videoTitle {
    color:#fff; padding:10px; text-align:center;
    font-size:16px; font-weight:bold;
  }
</style>
</head>
<body>
  <video id="video" autoplay crossorigin="anonymous"></video>
  <img id="subtitleOverlay" />
  <div id="controls">
    <label>Audio: <select id="audioSelector"></select></label>
    <label>Quality: <select id="qualitySelector"></select></label>
    <label>Subtitle: <select id="subtitleSelector"><option value="none">No Subtitles</option></select></label>
    <button id="playBtn">‚ñ∂Ô∏è Play</button>
    <button id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button id="muteBtn">üîä Mute</button>
    <button id="backwardBtn">‚è™ -10s</button>
    <button id="forwardBtn">‚è© +10s</button>
    <button id="fullscreenBtn">Fullscreen</button>
  </div>
  <div id="selectorBar">
    <label>Season: <select id="seasonSelect"></select></label>
    <label>Episode: <select id="episodeSelect"></select></label>
  </div>
  <div id="videoTitle"></div>

<script>
// --- Utilities ---
async function checkSubtitleExists(url){ 
  try{ const res=await fetch(url,{method:"HEAD"}); return res.ok; }
  catch{ return false; } 
}
function extractAudioTracks(m3uText){ 
  const tracks=[]; 
  const regex=/#EXT-X-MEDIA:TYPE=AUDIO.*?LANGUAGE="(.*?)".*?NAME="(.*?)".*?URI="(.*?)"/g; 
  let match;
  while((match=regex.exec(m3uText))!==null){ 
    tracks.push({lang:match[1],name:match[2],uri:match[3]}); 
  } 
  return tracks; 
}

// --- Subtitle Metadata Loader with fallback ---
async function fetchSubtitleMetadata(cdnHostname, transcodeUuid){
  const url = `https://${cdnHostname}/${transcodeUuid}/subtitle_metadata.json`;
  try {
    const res = await fetch(url);
    if(!res.ok){
      console.warn("Subtitle metadata not found, using fallback");
      return {
        eng:[],
        tha:[
          {codec:"VTT", pathName:"subtha", error:false},
          {codec:"VTT", pathName:"subtha1", error:false},
          {codec:"BDN", pathName:"subtha_2", error:false}
        ],
        default:[]
      };
    }
    const data = await res.json();
    return data;
  } catch(err){
    console.error("Error fetching subtitle metadata:", err);
    return {
      eng:[],
      tha:[
        {codec:"VTT", pathName:"subtha", error:false},
        {codec:"VTT", pathName:"subtha1", error:false},
        {codec:"BDN", pathName:"subtha_2", error:false}
      ],
      default:[]
    };
  }
}

// --- BDN Conversion ---
function timecodeToVTT(tc){
  const [hh,mm,ss,ms] = tc.split(/[:.]/).map(Number);
  const total = hh*3600 + mm*60 + ss + (ms||0)/1000;
  const h = String(Math.floor(total/3600)).padStart(2,"0");
  const m = String(Math.floor((total%3600)/60)).padStart(2,"0");
  const s = String(Math.floor(total%60)).padStart(2,"0");
  const msStr = String(Math.floor((total%1)*1000)).padStart(3,"0");
  return `${h}:${m}:${s}.${msStr}`;
}
function convertBDNtoVTT(xmlText){
  const xmlDoc = new DOMParser().parseFromString(xmlText,"application/xml");
  const events = xmlDoc.querySelectorAll("Event");
  let vtt = "WEBVTT\n\n";
  events.forEach((ev,idx)=>{
    const start = timecodeToVTT(ev.getAttribute("InTC"));
    const end = timecodeToVTT(ev.getAttribute("OutTC"));
    const g = ev.querySelector("Graphic");
    if(!g) return;
    const imgName = g.textContent.trim();
    vtt += `${idx+1}\n${start} --> ${end}\n${imgName}\n\n`;
  });
  return vtt;
}
async function loadBDNAsVTT(baseUrl, videoId, cdn, lang){
  const res = await fetch(`${baseUrl}/index.xml`);
  if(!res.ok) return {};
  const xmlText = await res.text();
  const folder = baseUrl.split('/').pop();
  const vttText = convertBDNtoVTT(xmlText);
  const blob = new Blob([vttText], {type:"text/vtt"});
  const vttUrl = URL.createObjectURL(blob);

  const track = document.createElement("track");
  track.kind = "subtitles";
  track.label = lang.toUpperCase();
  track.srclang = lang;
  track.src = vttUrl;
  track.mode = "hidden";
  video.appendChild(track);

  return {folder};
}

// --- Subtitle Rendering ---
const bdnSubtitles=[];
function renderSubtitleMenu(subtitles){
  const video=document.getElementById("video");
  const subtitleSelector=document.getElementById("subtitleSelector");
  subtitleSelector.innerHTML='<option value="none">No Subtitles</option>';
  bdnSubtitles.length=0;

  subtitles.forEach(sub=>{
    const opt=document.createElement("option");
    opt.value=sub.lang;
    opt.text=sub.lang.toUpperCase()+" ("+sub.codec+")";
    subtitleSelector.appendChild(opt);

    if(sub.codec==="VTT"){
      const track=document.createElement("track");
      track.kind="subtitles";
      track.label=sub.lang.toUpperCase();
      track.srclang=sub.lang;
      track.src=sub.src;
      video.appendChild(track);
    }
    if(sub.codec==="BDN"){
      bdnSubtitles.push(sub);
    }
  });

  subtitleSelector.onchange=async()=>{
    const selected=subtitleSelector.value;
    Array.from(video.textTracks).forEach(track=>track.mode="disabled");
    subtitleOverlay.style.display="none";
    subtitleOverlay.style.opacity="0";

    if(selected==="none") return;

    const vttTrack=Array.from(video.textTracks).find(
      t => t.srclang === selected || t.label.toLowerCase() === selected.toLowerCase()
    );
    if(vttTrack){
      vttTrack.mode="showing";
      return;
    }

    const bdnEntry=bdnSubtitles.find(sub=>sub.lang===selected);
    if(bdnEntry){
      const { folder }=await loadBDNAsVTT(
        bdnEntry.src.replace("/index.xml",""),
        bdnEntry.videoId,
        bdnEntry.cdn,
        bdnEntry.lang
      );
      activateBDNOverlay(folder, bdnEntry.videoId, bdnEntry.cdn, bdnEntry.lang);
    }
  };
}

// --- Responsive Overlay ---
function activateBDNOverlay(folder,videoId,cdn,lang){
  const track=Array.from(video.textTracks).find(
    t => t.srclang === lang || t.label.toLowerCase() === lang.toLowerCase()
  );
  if(!track) return;
  track.mode="hidden";

  video.addEventListener("timeupdate",()=>{
    const cue=Array.from(track.activeCues||[])[0];
    if(cue&&cue.text.trim()){
      const imgName=cue.text.replace(/<[^>]+>/g,"").trim();
      const imgURL=`https://${cdn}/${videoId}/${folder}/${imgName}`;
      subtitleOverlay.src=imgURL;
      subtitleOverlay.style.left=(video.clientWidth/2-(subtitleOverlay.width/2))+"px";
      subtitleOverlay.style.bottom=(video.clientHeight*0.08)+"px";
      subtitleOverlay.style.display="block";
      subtitleOverlay.style.opacity="1";
      cue.onexit = ()=>{ subtitleOverlay.style.opacity="0"; subtitleOverlay.style.display="none"; };
    } else {
      subtitleOverlay.style.opacity="0";
      subtitleOverlay.style.display="none";
    }
  });
}

// --- Movie Parser ---
async function fetchMovieById(movieId){ 
  const query=`query getMovie($id:Int!){ movie(id:$id){ id titleTh titleEn video{ transcodeUuid cdnHostname subtitleMetadata } } }`;
  const response=await fetch("https://api.doo-nang.com/graphql",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({query,variables:{id:movieId}})});
  const result=await response.json(); const movie=result?.data?.movie; if(!movie) return null;
  const transcodeUuid=movie.video?.transcodeUuid, cdnHostname=movie.video?.cdnHostname; let videoUrl="",subtitle=[],audioTracks=[];
  if(transcodeUuid&&cdnHostname){ 
    const base=`https://${cdnHostname}/${transcodeUuid}`; 
    videoUrl=`https://api.doo-nang.com/video/${transcodeUuid}/playlist.m3u8`;
    const metadata=await fetchSubtitleMetadata(cdnHostname,transcodeUuid);
    for(const [lang,subs] of Object.entries(metadata)){ 
      for(const sub of subs){ 
        let src;
        if(sub.codec==="VTT") src=`${base}/${sub.pathName}.vtt`; 
        else if(sub.codec==="BDN") src=`${base}/${sub.pathName}/index.xml`;
        if(await checkSubtitleExists(src)) subtitle.push({lang,codec:sub.codec,src,cdn:cdnHostname,videoId:transcodeUuid}); 
      } 
    }
    try{ const res=await fetch(videoUrl); if(res.ok) audioTracks=extractAudioTracks(await res.text()); }catch{} 
  }
  return { id:movie.id, title:movie.titleTh||movie.titleEn, video:videoUrl, subtitle, audioTracks }; 
}

// --- Series Parser ---
async function fetchSeriesById(showId){ 
  const query=`query getShow($id:Int!){ show(id:$id){ id titleTh titleEn episodes{ seasonNo episodeNo titleTh titleEn video{ transcodeUuid cdnHostname subtitleMetadata } } } }`;
  const response=await fetch("https://api.doo-nang.com/graphql",{
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify({query,variables:{id:showId}})
  });
  const result=await response.json(); 
  return result?.data?.show||null; 
}

async function processEpisode(ep){ 
  const transcodeUuid=ep.video?.transcodeUuid, cdnHostname=ep.video?.cdnHostname; 
  let videoUrl="",subtitle=[],audioTracks=[];
  if(transcodeUuid&&cdnHostname){ 
    const base=`https://${cdnHostname}/${transcodeUuid}`; 
    videoUrl=`https://api.doo-nang.com/video/${transcodeUuid}/playlist.m3u8`;

    // ‚úÖ ‡πÉ‡∏ä‡πâ subtitle_metadata.json ‡∏û‡∏£‡πâ‡∏≠‡∏° fallback
    const metadata=await fetchSubtitleMetadata(cdnHostname,transcodeUuid);
    for(const [lang,subs] of Object.entries(metadata)){ 
      for(const sub of subs){ 
        let src;
        if(sub.codec==="VTT") src=`${base}/${sub.pathName}.vtt`; 
        else if(sub.codec==="BDN") src=`${base}/${sub.pathName}/index.xml`;
        if(await checkSubtitleExists(src)) subtitle.push({lang,codec:sub.codec,src,cdn:cdnHostname,videoId:transcodeUuid}); 
      } 
    }

    try{ 
      const res=await fetch(videoUrl); 
      if(res.ok) audioTracks=extractAudioTracks(await res.text()); 
    }catch{} 
  }
  return { 
    season:ep.seasonNo, 
    episode:ep.episodeNo, 
    title:ep.titleTh||ep.titleEn||`EP${ep.episodeNo}`, 
    video:videoUrl, 
    subtitle, 
    audioTracks 
  }; 
}

// --- Clear and Load Episode ---
function clearSubtitles(){
  const video=document.getElementById("video");
  Array.from(video.querySelectorAll("track")).forEach(t=>t.remove());
}

async function loadEpisode(ep){
  const episodeData = await processEpisode(ep);
  if(!episodeData) return;

  // ‡πÇ‡∏´‡∏•‡∏î video ‡πÉ‡∏´‡∏°‡πà
  video.src = episodeData.video;

  // ‚úÖ ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå subtitle ‡πÄ‡∏î‡∏¥‡∏°
  clearSubtitles();

  // ‚úÖ ‡πÇ‡∏´‡∏•‡∏î subtitle ‡πÉ‡∏´‡∏°‡πà
  renderSubtitleMenu(episodeData.subtitle);

  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á
  document.getElementById("videoTitle").textContent = episodeData.title;
}

// --- Load Series Episode by ids param ---
async function loadSeriesEpisode(showId, seasonNo, episodeNo){
  const series = await fetchSeriesById(showId);
  if(!series) return;

  const ep = series.episodes.find(
    e => e.seasonNo === seasonNo && e.episodeNo === episodeNo
  );
  if(!ep) return;

  await loadEpisode(ep);
}
</script>

<!-- Script Part 2: Player Init + Init Page -->
<script>
// --- Player Init ---
function initPlayer(videoURL){
  const video=document.getElementById("video");
  const audioSelector=document.getElementById("audioSelector");
  const qualitySelector=document.getElementById("qualitySelector");

  if(Hls.isSupported()){
    const hls=new Hls();
    hls.attachMedia(video);
    hls.loadSource(videoURL);

    hls.on(Hls.Events.MANIFEST_PARSED,()=>{
      // Audio menu
      audioSelector.innerHTML='';
      hls.audioTracks.forEach((track,i)=>{
        const opt=document.createElement("option");
        opt.value=i;
        opt.text=`${track.name||'Track'} (${track.lang||'und'})`;
        audioSelector.appendChild(opt);
      });
      audioSelector.onchange=()=>{ hls.audioTrack=parseInt(audioSelector.value); };

      // Quality menu
      qualitySelector.innerHTML='<option value="-1">Auto</option>';
      hls.levels.forEach((level,i)=>{
        const label=level.height?`${level.height}p`:`${Math.round(level.bitrate/1000)}kbps`;
        const opt=document.createElement("option");
        opt.value=i; opt.text=label;
        qualitySelector.appendChild(opt);
      });
      qualitySelector.onchange=()=>{ hls.currentLevel=parseInt(qualitySelector.value); };
    });
  } else if(video.canPlayType("application/vnd.apple.mpegurl")){
    video.src=videoURL;
  }
}

// --- Init Page ---
window.onload = async () => {
  const params = new URLSearchParams(window.location.search);
  const type = params.get("type");
  const ids = params.get("ids");

  if(type==="movie" && ids){
    const movie = await fetchMovieById(parseInt(ids,10));
    if(movie){
      initPlayer(movie.video);
      renderSubtitleMenu(movie.subtitle);
      document.getElementById("videoTitle").innerText = movie.title;
    } else {
      document.getElementById("videoTitle").innerText = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏ô‡∏±‡∏á";
    }
  } else if(type==="series" && ids){
    const show = await fetchSeriesById(parseInt(ids,10));
    if(show){
      document.title = `${show.titleTh} (${show.titleEn})`;
      const seasonSelect=document.getElementById("seasonSelect");
      const episodeSelect=document.getElementById("episodeSelect");
      const selectorBar=document.getElementById("selectorBar");
      selectorBar.style.display="flex";

      const seasonMap={};
      show.episodes.forEach(ep=>{
        if(!seasonMap[ep.seasonNo]) seasonMap[ep.seasonNo]=[];
        seasonMap[ep.seasonNo].push(ep);
      });

      Object.keys(seasonMap).forEach(seasonNo=>{
        const opt=document.createElement("option");
        opt.value=seasonNo; opt.text=`Season ${seasonNo}`;
        seasonSelect.appendChild(opt);
      });

      async function loadEpisodes(seasonNo){
        episodeSelect.innerHTML="";
        seasonMap[seasonNo].forEach(ep=>{
          const opt=document.createElement("option");
          opt.value=ep.episodeNo;
          opt.text=`Episode ${ep.episodeNo} - ${ep.titleTh||ep.titleEn}`;
          episodeSelect.appendChild(opt);
        });

        // ‡πÇ‡∏´‡∏•‡∏î‡∏ï‡∏≠‡∏ô‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á season ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
        const firstEp = seasonMap[seasonNo][0];
        const epData = await processEpisode(firstEp);
        initPlayer(epData.video);
        renderSubtitleMenu(epData.subtitle);
        document.getElementById("videoTitle").innerText = epData.title;
      }

      // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô season
      seasonSelect.addEventListener("change", ()=>loadEpisodes(seasonSelect.value));

      // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô episode
      episodeSelect.addEventListener("change", async ()=>{
        const seasonNo = seasonSelect.value;
        const episodeNo = episodeSelect.value;
        const ep = seasonMap[seasonNo].find(e => String(e.episodeNo) === episodeNo);
        if(ep){
          const epData = await processEpisode(ep);
          initPlayer(epData.video);
          renderSubtitleMenu(epData.subtitle);
          document.getElementById("videoTitle").innerText = epData.title;
        }
      });

      // ‡πÇ‡∏´‡∏•‡∏î season ‡πÅ‡∏£‡∏Å‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
      const firstSeason = Object.keys(seasonMap)[0];
      seasonSelect.value = firstSeason;
      await loadEpisodes(firstSeason);

    } else {
      document.getElementById("videoTitle").innerText = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏µ‡∏£‡∏µ‡∏™‡πå";
    }
  }
};
</script>
<script>
  // --- ‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏´‡∏•‡∏±‡∏Å ---
document.getElementById("playBtn").addEventListener("click",()=>video.play());
document.getElementById("pauseBtn").addEventListener("click",()=>video.pause());
document.getElementById("muteBtn").addEventListener("click",()=>{
  video.muted=!video.muted;
  document.getElementById("muteBtn").textContent=video.muted?"üîá Unmute":"üîä Mute";
});
document.getElementById("forwardBtn").addEventListener("click",()=>video.currentTime+=10);
document.getElementById("backwardBtn").addEventListener("click",()=>video.currentTime-=10);
// --- Fullscreen Button --- 
  const fullscreenBtn=document.getElementById("fullscreenBtn"); 
  fullscreenBtn.addEventListener("click",()=>{ 
    if(!document.fullscreenElement){ 
      document.body.requestFullscreen(); 
    } else { 
      document.exitFullscreen(); 
    } 
  }); 
  document.addEventListener("fullscreenchange",()=>{ 
    fullscreenBtn.textContent=document.fullscreenElement?"Exit Fullscreen":"Fullscreen"; 
  }); 
</script>
</body>
</html>
