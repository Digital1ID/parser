<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <title>Doo-Parser Player</title>
  <style>
    body { margin:0; background:#000; width:100vw; height:100vh; display:flex; flex-direction:column; }
    #videoTitle { color:#fff; padding:10px; }
    #selectorBar { background:#111; color:#fff; padding:10px; display:flex; gap:20px; flex-wrap:wrap; }
    select, button { padding:6px; margin:2px; }
    video { width:100%; height:100%; background:#000; }
    #subtitleOverlay {
      position: fixed;
      bottom: 8%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      pointer-events: none;
      display: none;
      transition: opacity 0.3s ease-in-out;
      max-width: 60%;
      max-height: 25%;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.7));
      border-radius: 6px;
      background-color: rgba(0,0,0,0.2);
    }
    #controls { background:#222; padding:10px; display:flex; gap:10px; justify-content:center; }
    #controls button { background:#444; color:#fff; border:none; padding:8px 12px; cursor:pointer; border-radius:4px; }
    #controls button:hover { background:#666; }
  </style>
</head>
<body>
  <div id="selectorBar">
    <label for="seasonSelect">‡∏ã‡∏µ‡∏ã‡∏±‡πà‡∏ô:</label>
    <select id="seasonSelect"></select>
    <label for="episodeSelect">‡∏ï‡∏≠‡∏ô:</label>
    <select id="episodeSelect"></select>
    <label for="audioSelector">‡πÄ‡∏™‡∏µ‡∏¢‡∏á:</label>
    <select id="audioSelector"></select>
    <label for="qualitySelector">‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û:</label>
    <select id="qualitySelector"></select>
    <label for="subtitleSelector">‡∏ã‡∏±‡∏ö:</label>
    <select id="subtitleSelector"></select>
  </div>
  <video id="video" controls></video>
  <img id="subtitleOverlay">
  <div id="controls">
    <button id="playPause">‚ñ∂Ô∏è/‚è∏Ô∏è</button>
    <button id="stop">‚èπÔ∏è</button>
    <button id="mute">üîá/üîä</button>
    <button id="fullscreen">‚õ∂</button>
  </div>
  <div id="videoTitle"></div>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
const video = document.getElementById('video');
const audioSelector = document.getElementById('audioSelector');
const qualitySelector = document.getElementById('qualitySelector');
const subtitleSelector = document.getElementById('subtitleSelector');
const subtitleOverlay = document.getElementById('subtitleOverlay');

let activeCDN = null;

// --- Subtitle BDN ---
function timecodeToVTT(tc) {
  const [hh, mm, ss, ff] = tc.split(":").map(Number);
  const total = hh * 3600 + mm * 60 + ss + (ff || 0) / 25;
  const h = String(Math.floor(total / 3600)).padStart(2, "0");
  const m = String(Math.floor((total % 3600) / 60)).padStart(2, "0");
  const s = String(Math.floor(total % 60)).padStart(2, "0");
  const ms = String(Math.floor((total % 1) * 1000)).padStart(3, "0");
  return `${h}:${m}:${s}.${ms}`;
}

function convertBDNtoVTT(xmlText) {
  const xmlDoc = new DOMParser().parseFromString(xmlText, "application/xml");
  const events = xmlDoc.querySelectorAll("Event");
  let vtt = "WEBVTT\n\n";
  events.forEach((ev, idx) => {
    const start = timecodeToVTT(ev.getAttribute("InTC"));
    const end = timecodeToVTT(ev.getAttribute("OutTC"));
    const g = ev.querySelector("Graphic");
    if (!g || !g.textContent) return;
    const imgName = g.textContent.trim();
    vtt += `${idx + 1}\n${start} --> ${end}\n<c.subimg>${imgName}</c>\n\n`;
  });
  return vtt;
}

async function loadBDNAsVTT(baseUrl, videoId, cdn) {
  const url = `${baseUrl}/index.xml`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("Failed to fetch BDN XML");
  const xmlText = await res.text();
  const folder = baseUrl.split('/').pop();
  const vttText = convertBDNtoVTT(xmlText);
  const blob = new Blob([vttText], { type: "text/vtt" });
  const vttUrl = URL.createObjectURL(blob);

  const track = document.createElement("track");
  track.kind = "subtitles";
  track.label = "BDN";
  track.srclang = "und";
  track.src = vttUrl;
  track.default = true;
  video.appendChild(track);

  activateBDNOverlay(folder, videoId, cdn);
}

function activateBDNOverlay(folder, videoId, cdn) {
  const track = Array.from(video.textTracks).find(t => t.label === "BDN");
  if (!track) return;
  track.mode = "hidden";

  video.addEventListener("timeupdate", () => {
    const cue = Array.from(track.activeCues || [])[0];
    if (cue && cue.text.trim()) {
      const imgName = cue.text.replace(/<[^>]+>/g, "").trim();
      const imgURL = `https://${cdn}/${videoId}/${folder}/${imgName}`;
      subtitleOverlay.src = imgURL;
      subtitleOverlay.style.display = "block";
      subtitleOverlay.style.opacity = "1";
    } else {
      subtitleOverlay.style.opacity = "0";
      subtitleOverlay.style.display = "none";
    }
  });
}

// --- Player Init ---
async function initPlayer(videoURL, videoId, cdn) {
  activeCDN = cdn;
  if (Hls.isSupported()) {
    const hls = new Hls();
    hls.attachMedia(video);
    hls.loadSource(videoURL);

    hls.on(Hls.Events.MANIFEST_PARSED, () => {
      // Audio track
      audioSelector.innerHTML = '';
      hls.audioTracks.forEach((track, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        opt.text = `${track.name || 'Track'} (${track.lang || 'und'})`;
        audioSelector.appendChild(opt);
      });
      audioSelector.onchange = () => {
        hls.audioTrack = parseInt(audioSelector.value);
      };

      // Quality
      qualitySelector.innerHTML = '<option value="-1">Auto</option>';
      hls.levels.forEach((level, i) => {
        const label = level.height ? `${level.height}p` : `${Math.round(level.bitrate / 1000)}kbps`;
        const opt = document.createElement('option');
        opt.value = i;
        opt.text = label;
        qualitySelector.appendChild(opt);
      });
      qualitySelector.onchange = () => {
        hls.currentLevel = parseInt(qualitySelector.value);
      };
    });
  } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
    video.src = videoURL;
  }
}

// --- Controls ---
document.getElementById("playPause").onclick = () => {
  if(video.paused) video.play(); else video.pause();
};
document.getElementById("stop").onclick = () => {
  video.pause(); video.currentTime = 0;
};
document.getElementById("mute").onclick = () => {
  video.muted = !video.muted;
};
document.getElementById("fullscreen").onclick = () => {
  if(video.requestFullscreen) video.requestFullscreen();
};

// --- Init Page ---
window.onload = async () => {
  const params = new URLSearchParams(window.location.search);
  const type = params.get("type");
  const ids = params.get("ids");

  if(type === "movie" && ids){
    const movie = await fetchMovieById(parseInt(ids,10)); // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô fetchMovieById
    if(movie){
      initPlayer(movie.video, movie.id, movie.cdnHostname);
      document.getElementById("videoTitle").innerText = movie.title;
    } else {
      document.getElementById("videoTitle").innerText = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏ô‡∏±‡∏á";
    }
  } else if(type === "series" && ids){
    const show = await fetchSeriesById(parseInt(ids,10)); // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô fetchSeriesById
    if(show){
      document.title = `${show.titleTh} (${show.titleEn})`;
      const seasonSelect = document.getElementById("seasonSelect");
      const episodeSelect = document.getElementById("episodeSelect");
      const selectorBar = document.getElementById("selectorBar");
      selectorBar.style.display = "flex";

      // Group episodes by season
      const seasonMap = {};
      show.episodes.forEach(ep=>{
        if(!seasonMap[ep.seasonNo]) seasonMap[ep.seasonNo] = [];
        seasonMap[ep.seasonNo].push(ep);
      });

      Object.keys(seasonMap).forEach(seasonNo=>{
        const opt = document.createElement("option");
        opt.value = seasonNo; opt.text = `Season ${seasonNo}`;
        seasonSelect.appendChild(opt);
      });

      async function loadEpisodes(seasonNo){
        episodeSelect.innerHTML = "";
        seasonMap[seasonNo].forEach(ep=>{
          const opt = document.createElement("option");
          opt.value = ep.episodeNo;
          opt.text = `Episode ${ep.episodeNo} - ${ep.titleTh||ep.titleEn}`;
          episodeSelect.appendChild(opt);
        });
        const firstEp = seasonMap[seasonNo][0];
        const epData = await processEpisode(firstEp); // ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô processEpisode
        initPlayer(epData.video, epData.episode, show.cdnHostname);
        document.getElementById("videoTitle").innerText = epData.title;
      }

      seasonSelect.addEventListener("change", ()=>loadEpisodes(seasonSelect.value));
      episodeSelect.addEventListener("change", async ()=>{
        const seasonNo = seasonSelect.value, episodeNo = episodeSelect.value;
        const ep = seasonMap[seasonNo].find(e=>String(e.episodeNo)===episodeNo);
        if(ep){
          const epData = await processEpisode(ep);
          initPlayer(epData.video, epData.episode, show.cdnHostname);
          document.getElementById("videoTitle").innerText = epData.title;
        }
      });

      // ‡πÇ‡∏´‡∏•‡∏î‡∏ã‡∏µ‡∏ã‡∏±‡πà‡∏ô‡πÅ‡∏£‡∏Å‡πÅ‡∏•‡∏∞‡∏ï‡∏≠‡∏ô‡πÅ‡∏£‡∏Å‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
      const firstSeason = Object.keys(seasonMap)[0];
      seasonSelect.value = firstSeason;
      await loadEpisodes(firstSeason);
    } else {
      document.getElementById("videoTitle").innerText = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ã‡∏µ‡∏£‡∏µ‡∏™‡πå";
    }
  }
};
</script>
</body>
</html>

