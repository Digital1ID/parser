<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <title>Anime-Good Playlist Parser</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f9f9f9; padding: 20px; }
    pre { background: #222; color: #0f0; padding: 10px; overflow-x: auto; }
    .series { margin-bottom: 30px; }
    .poster { max-width: 200px; }
  </style>
</head>
<body>
  <h1>Anime-Good Playlist Parser</h1>
  <div id="output"></div>

<script>
async function fetchViaProxy(url) {
  const proxyUrl = `/api/proxy-good?url=${encodeURIComponent(url)}`;
  const res = await fetch(proxyUrl);
  if (!res.ok) return null;
  return await res.text();
}

// üì∫ Extract episodes ‡∏à‡∏≤‡∏Å ul#MVP
function extractEpisodesFromMVP(doc) {
  const epItems = doc.querySelectorAll("ul#MVP li.mvp a");
  let episodes = [];
  epItems.forEach(a => {
    const url = a.href;
    const title = a.getAttribute("title") || a.textContent.trim();
    const epNum = parseInt((a.querySelector(".eptitle")?.textContent || "0").trim(), 10);
    if (epNum) {
      episodes.push({ episode: epNum, title, url });
    }
  });
  return episodes;
}

// üîó Extract embed code ‡∏à‡∏≤‡∏Å iframe, toolbar, ‡∏´‡∏£‡∏∑‡∏≠ fallback class
function extractEmbedCode(doc, epUrl) {
  // 1. iframe ‡∏õ‡∏Å‡∏ï‡∏¥
  const iframe = doc.querySelector("iframe");
  if (iframe && iframe.src) {
    const match = iframe.src.match(/\/embed\/([a-zA-Z0-9_-]+)\//);
    if (match) return match[1];
  }

  // 2. toolbar player (active)
  const playerItem = doc.querySelector(".toolbar-item.mp-s-sl.active");
  if (playerItem) {
    const dataId = playerItem.getAttribute("data-id");
    const match = dataId.match(/\/embed\/([a-zA-Z0-9_-]+)\//);
    if (match) return match[1];
  }

  // 3. fallback class mpIframe
  const mpIframe = doc.querySelector(".mpIframe");
  if (mpIframe) {
    const className = mpIframe.className;
    const postIdMatch = className.match(/iframe-([0-9]+)/);
    if (postIdMatch) return postIdMatch[1];
  }

  // 4. fallback ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢: ‡πÉ‡∏ä‡πâ slug ‡∏Ç‡∏≠‡∏á episode URL
  return epUrl.split("/").filter(Boolean).pop();
}

// ‡πÅ‡∏õ‡∏•‡∏á embed code ‚Üí .m3u8
function convertCodeToM3U8(code) {
  return code ? `https://moji.abcdxzy.xyz:8443/vod/${code}/video.mp4/playlist.m3u8` : null;
}

// ‡∏™‡∏£‡πâ‡∏≤‡∏á playlist .m3u
function generateM3U(seriesData) {
  let m3u = "#EXTM3U\n";
  const logo = seriesData.poster || "";
  const title = seriesData.title || "‡∏ã‡∏µ‡∏£‡∏µ‡∏™‡πå";
  for (const ep of seriesData.episodes) {
    if (ep.video) {
      m3u += `#EXTINF:-1 tvg-logo="${logo}" tvg-season="1" tvg-episode="${ep.episode}", ${title} S01 EP${String(ep.episode).padStart(2,"0")}\n`;
      m3u += ep.video + "\n";
    }
  }
  return m3u;
}

// ‡∏™‡∏£‡πâ‡∏≤‡∏á JSON Output
function generateJSON(seriesData) {
  return [{
    id: seriesData.id || "",
    name: seriesData.title || "",
    category: "‡∏≠‡∏ô‡∏¥‡πÄ‡∏°‡∏∞",
    info: {
      poster: seriesData.poster || "",
      description: seriesData.synopsis || "",
      year: new Date().getFullYear()
    },
    seasons: [
      {
        season: 1,
        name: "Season 1",
        info: {
          poster: seriesData.poster || "",
          description: seriesData.synopsis || "",
          year: new Date().getFullYear()
        },
        episodes: seriesData.episodes.map(ep => ({
          episode: ep.episode,
          name: ep.title,
          video: ep.video || "",
          referrer: "https://anime-good.com/"
        }))
      }
    ]
  }];
}

async function main() {
  const params = new URLSearchParams(window.location.search);
  const ids = params.get("ids")?.split(",") || ["one-punch-man-season-3-th"];
  const output = document.getElementById("output");
  output.innerHTML = "Loading...";

  for (const id of ids) {
    const seriesUrl = `https://anime-good.com/${id}/`;
    const html = await fetchViaProxy(seriesUrl);
    if (!html) {
      output.innerHTML += `<p>‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${id}</p>`;
      continue;
    }

    const doc = new DOMParser().parseFromString(html, "text/html");

    // ‚úÖ ‡∏î‡∏∂‡∏á title
    const title = doc.querySelector("h2.wp-block-heading")?.textContent.trim() || id;

// ‚úÖ ‡∏î‡∏∂‡∏á poster ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
let poster = "";
const posterImg = doc.querySelector(".post-thumnail img");
if (posterImg) {
  poster = posterImg.getAttribute("data-src") 
        || posterImg.getAttribute("src") 
        || "";
  if (poster.startsWith("data:image/svg")) {
    const noscriptImg = posterImg.parentElement.querySelector("noscript img");
    if (noscriptImg) {
      poster = noscriptImg.getAttribute("src") || poster;
    }
  }
}

    // ‚úÖ ‡∏î‡∏∂‡∏á description ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    let synopsis = "";
    const heading = doc.querySelector("h2.wp-block-heading");
    if (heading) {
      const nextP = heading.nextElementSibling;
      if (nextP && nextP.tagName.toLowerCase() === "p") {
        synopsis = nextP.textContent.trim();
      }
    }

    // ‡∏î‡∏∂‡∏á episodes
    const episodesRaw = extractEpisodesFromMVP(doc);
    let episodes = [];
    for (const ep of episodesRaw) {
      const epHtml = await fetchViaProxy(ep.url);
      const epDoc = new DOMParser().parseFromString(epHtml, "text/html");
      let code = extractEmbedCode(epDoc, ep.url);
      const m3u8 = convertCodeToM3U8(code);
      episodes.push({ episode: ep.episode, title: ep.title, video: m3u8 });
    }

    const seriesData = { id, poster, title, synopsis, episodes };
    const m3u = generateM3U(seriesData);
    const jsonData = generateJSON(seriesData);

    output.innerHTML += `
      <div class="series">
        <h2>${title}</h2>
        <img class="poster" src="${poster}" alt="${title}">
        <p>${synopsis}</p>
        <h3>Playlist (.m3u)</h3>
        <pre>${m3u}</pre>
        <h3>JSON Data</h3>
        <pre>${JSON.stringify(jsonData, null, 2)}</pre>
      </div>
    `;
  }
}

main();
</script>
</body>
</html>